<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[java内部类学习]]></title>
      <url>%2F2017%2F05%2F29%2Fjava%2F%E5%86%85%E9%83%A8%E7%B1%BB%2F2017-05-29%2F</url>
      <content type="text"><![CDATA[java内部类学习： 内部类的作用: 1.内部类可以很好的实现隐藏 一般的非内部类，是不允许有 private 与protected权限的，但内部类可以 2.内部类拥有外围类的所有元素的访问权限 3.可是实现多重继承(使用内部类去继承其他类实现 外部类的间接多继承) 4.可以避免修改接口而实现同一个类中两种同名方法的调用。 (继承的父类和实现的接口类中的方法名相同时，可以用内部类来实现接口，外部类继承其他类，这样就不会与外围类的方法冲突了) 注意：1.内部类可以随意的访问外部类的成员。包括private等修饰符修饰的变量和方法。但是外部类不能轻松的访问内部类的成员，必须常见一个内部类的实例再去访问。2.内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。 内部类的类型：成员内部类：成员内部类是最普通的内部类，定义在主类体内部的类，类似该类的成员。成员内部类是依附外部类而存在的.1234567891011121314151617181920212223242526public class Test &#123; public static void main(String[] args) &#123; //第一种方式： Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); //必须通过Outter对象来创建 //第二种方式： Outter.Inner inner1 = outter.getInnerInstance(); &#125;&#125; class Outter &#123; private Inner inner = null; public Outter() &#123;&#125; //获取内部类实例对象的方法（单例模式） public Inner getInnerInstance() &#123; if(inner == null) inner = new Inner(); return inner; &#125; class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 局部内部类：局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。12345678910111213class People &#123;&#125;class Man &#123; //局部内部类 public People getWoman() &#123; class Woman extends People &#123; //局部内部类 int age = 23; &#125; return new Woman(); &#125;&#125; 匿名内部类： 1、 匿名内部类是没有访问修饰符的。 2、 new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。 3、 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。4、 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。 12345678910111213141516171819202122232425262728public class OuterClass &#123; public InnerClass getInnerClass(final int num,String str2)&#123; return new InnerClass()&#123; int number = num + 3; public int getNumber()&#123; return number; &#125; &#125;; /* 注意：分号不能省 */ &#125; public static void main(String[] args) &#123; OuterClass out = new OuterClass(); InnerClass inner = out.getInnerClass(2, &quot;chenssy&quot;); System.out.println(inner.getNumber()); //inner.method4(); &#125;&#125;interface InnerClass &#123; int getNumber();&#125;//class InnerClass&#123;// int getNumber()&#123;&#125;;//// public void method4() &#123;// System.out.println(&quot;匿名内部类 method4&quot;);// &#125;//&#125; 静态内部类：static声明的内部类。静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。12345678910111213141516public class Test &#123; public static void main(String[] args) &#123;//不依赖外部类的实例去创建静态内部类的实例对象 Outter.Inner inner = new Outter.Inner(); &#125;&#125; class Outter &#123; public Outter() &#123; &#125; static class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 参考：http://blog.csdn.net/a1259109679/article/details/48156407http://andy136566.iteye.com/blog/1061951/http://www.cnblogs.com/chenssy/p/3388487.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java反射机制之获取类信息的Util]]></title>
      <url>%2F2017%2F05%2F28%2Fjava%2F%E5%8F%8D%E5%B0%84%2F2017-05-28%2F</url>
      <content type="text"><![CDATA[#java反射机制之获取类信息的Util 学习反射期间编写的一个能获取类的信息（包括成员变量，成员方法以及构造函数信息）的Util类。对于java反射操作的关键，获取类类型（Class）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * Created by g-Linlf on 2017/5/28. **/public class ClassUtil &#123; //获取对象的所有信息 成员方法 public static void getMethodsMessage(Object obj) &#123; // 获取类类型 //String name = obj.getClass().getName(); //System.out.println(name); //System.out.println(obj.getClass().getSimpleName()); Class tClass = obj.getClass(); //tClass = Class.forName(name); System.out.println(&quot;类名为:&quot; + tClass.getName()); //获取成员方法 ，万事万物接对象 Method类为方法的对象 //Object[] methods = tClass.getMethods(); Method[] methods = tClass.getMethods();//获取到所有public的函数，包括父类继承过来的 //Method[] methods = tClass.getDeclaredMethods();//获取到该类所有自己声明的方法，不论访问权限。 for (Method method : methods) &#123; //System.out.println(method); //获得返回值类类型 Class returnType = method.getReturnType(); System.out.print(returnType.getSimpleName() + &quot; &quot;); //获得方法名 System.out.print(method.getName() + &quot;(&quot;); //获取参数 //获取参数类型 Class[] paramsType = method.getParameterTypes(); //for (Class class1 : paramsType) &#123; // System.out.print(class1.getName() + &quot;,&quot;); //&#125; for (int i = 0; i &lt; paramsType.length; i++) &#123; if (i == paramsType.length - 1) &#123; System.out.print(paramsType[i].getName()); &#125; else &#123; System.out.print(paramsType[i].getName() + &quot;,&quot;); &#125; &#125; System.out.println(&quot;)&quot;); &#125; &#125; //获取对象的成员变量 public static void getFieldMessage(Object obj) &#123; Class tClass = obj.getClass(); /** * 成员变量也是对象 * Field封装了关于成员变量的操作 * */ System.out.println(&quot;--------成员变量---------&quot;); //getFields()获取到所有public的成员变量 getDeclaredFields()获取到该类自己声明的成员变量 //Field[] fields = tClass.getFields(); Field[] fields = tClass.getDeclaredFields(); for (Field field : fields) &#123; //System.out.println(field); //变量类型 System.out.print(field.getType() + &quot; &quot;); // 变量名 System.out.println(field.getName()); &#125; &#125; //获取对象的构造函数信息（构造函数 也是对象） public static void getConMessage(Object obj) &#123; Class tClass = obj.getClass(); /** * java.lang.Constructor封装了构造函数的信息 * getConstructors() 获取所有public的构造函数 * getDeclaredConstructors() 获取对象定义的构造函数 */ //Constructor[] cons = tClass.getConstructors(); Constructor[] cons = tClass.getDeclaredConstructors(); for (Constructor con : cons) &#123; //获取构造函数的名 System.out.print(con.getName() + &quot;(&quot;); //获取构造函数的参数列表 Class[] paramsType = con.getParameterTypes(); for (int i = 0; i &lt; paramsType.length; i++) &#123; if (i != paramsType.length - 1) &#123; System.out.print(paramsType[i].getSimpleName() + &quot;,&quot;); &#125; else &#123; System.out.print(paramsType[i].getSimpleName()); &#125; System.out.println(&quot;)&quot;); &#125; &#125; &#125; public static void main(String args[]) &#123; //ClassUtil.getMethodsMessage(&quot;123&quot;); Integer num = 1; //ClassUtil.getFieldMessage(num); ClassUtil.getConMessage(num); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构 队列 之java实现]]></title>
      <url>%2F2017%2F05%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F2017-05-27-1%2F</url>
      <content type="text"><![CDATA[数据结构 队列 之java实现 队列：队列是一种先进先出的线性表（FIFO），它只允许在表的一端进行插入，而在另一端删除元素。在队列中，允许插入数据一端成为队尾（rear），允许删除的那一端称为队头（front）。 队列的基本操作：isEmpty() 判断空队列isFull() 判断满队列put() 入队列get() 出队列取队首元素（返回队首元素，不修改队首指针）清空队列 -顺序队列：顺序队列利用一组地址连续的存储单元依次存放自队首到队尾的数据元素，同时由于队的操作的特殊性，还必须附两个位置指针front和rear来动态地指示队首元素和队尾元素在顺序队列中的位置。通常front=rear表示空队列。（rear+1）%maxSize = front表示队满。 -链式队列：采用链表作为存储结构实现的队列。为便于操作，采用带头结点的单链表实现队列。因为队列的插入和删除操作位置不同，所以链表需要设置表头指针和表尾指针分别指队首和队尾。 -循环队列：假设向量的空间是m,只要在入出队列时，将队首和队尾的指针对m做求模运算即可实现队首和队尾指针的循环，即队首和队尾指针的取值范围是0到m-1之间。 java值demo实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * Created by g-Linlf on 2017/5/26. * 顺序队列 * 链式队列 * 循环队列 **/public class TestQueue &#123; public static void main(String args[]) throws Exception &#123; LinkedListQueue queue1 = new LinkedListQueue(); queue1.put(1); //queue1.put(1); queue1.clear(); System.out.println(queue1.size()); queue1.put(1); System.out.println(queue1.get()); System.out.println(queue1.isEmpty()); System.out.println(&quot;====================&quot;); ArrayQueue arrayQueue = new ArrayQueue(2); arrayQueue.put(2); arrayQueue.put(7); System.out.println(arrayQueue.isFull()); System.out.println(arrayQueue.size()); System.out.println(arrayQueue.get()); System.out.println(arrayQueue.isEmpty()); arrayQueue.clear(); arrayQueue.put(3); System.out.println(&quot;====================&quot;); Queue queue3 = new LinkedBlockingQueue();// Queue queue4 = new ArrayBlockingQueue(2);// Object[] objects = new Object[2]; System.out.println(objects[1] == null); &#125;&#125;//使用LinkedList实现class LinkedListQueue &#123; private LinkedList ll = new LinkedList(); //入队操作 public void put(Object o) &#123; ll.addLast(o); &#125; //使用removeFirst()方法，返回队列中第一个数据，然后将它从队列 中删除 //出队操作 public Object get() &#123; return ll.removeFirst(); &#125; public boolean isEmpty() &#123; return ll.isEmpty(); &#125; //队列大小 public int size() &#123; return ll.size(); &#125; //清空队列 public void clear() &#123; ll = null; ll = new LinkedList(); &#125;&#125;//使用数组实现class ArrayQueue &#123; private int maxSize; private Object[] queue; private int front; //头指针 允许删除 private int rear; //尾指针 允许插入数据 public ArrayQueue(int size) &#123; maxSize = size + 1; //尾指针指向下一个位置（该位置为空） queue = new Object[maxSize]; front = 0; rear = 0; &#125; public void put(Object value) &#123; if (isFull()) &#123; System.out.println(&quot;Full!&quot;); //throw new RuntimeException(&quot;queue is full!&quot;); return; &#125; queue[rear] = value; rear = (rear + 1) % queue.length; &#125; public Object get() throws Exception &#123; Object value; if (isEmpty()) &#123; throw new RuntimeException(&quot;Empty!&quot;); &#125; value = queue[front]; queue[front] = null; //释放对象 front = (front + 1) % queue.length; return value; &#125; //获取实际存储数据大小 public int size() &#123; return (rear - front); &#125; //清空队列 public void clear() &#123; queue = null; queue = new Object[maxSize]; &#125; public boolean isEmpty() &#123; return rear == front; &#125; public boolean isFull() &#123; return rear + 1 - front == queue.length; //return (rear + 1) % maxSize == front; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构 栈 之java实现]]></title>
      <url>%2F2017%2F05%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F2017-05-27%2F</url>
      <content type="text"><![CDATA[数据结构 栈 之java实现 栈：是限制在表的一端进行插入和删除运算的线性表，通常称插入、删除的这一端为栈顶，另一端为栈底。当表中没有元素时成为空栈。（LIFO）后进先出 栈的基本操作： initStack() //初始化clearStack() //清空栈stackEmpty() //判断栈是否为空stackFull() //判断栈是否满栈getTop() //获取栈顶元素push() //从栈顶压入一个元素pop() //从栈顶删除（取出）一个元素stackLength() //计算堆栈中元素的个数 顺序栈：顺序栈利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时由于栈的操作的特殊性，还必须附设一个位置指针top来动态地指示栈顶元素的顺序栈中的位置。通常以top=0表示空栈。（java中使可用数组实现栈的基本操作） 链栈：采用链表作为存储结构实现的栈。为便于操作，采用带头结点的单链表实现栈。（java中使用LinkedArray 可以实现栈的基本操作，java也已经有相应的Stack类及其方法） 顺序栈和链栈的比较：实现链式栈和顺序栈的操作都是需要常数时间，即时间复杂度为O（1），主要从空间和时间两个方面考虑。初始时，顺序堆栈必须说明一个固定的长度，当堆栈不够满时，造成一些空间的浪费；而链式堆栈的长度可变则使长度不需要预先设定，动态增减，相对比较节省空间，但是在每个节点中设置了一个指针域，从而产生了结构开销。 具体demo实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * Created by g-Linlf on 2017/5/26. * &lt;p&gt; * 方法一使用LinkedList实现栈（链栈） * (类似链表的栈实现，因为链表不用担心容量的问题) * 方法二使用数组实现（顺序栈） * 有容量限制。 **/public class TestStack &#123; public static void main(String args[]) &#123; LinkedListStack stack = new LinkedListStack(); stack.push(1); System.out.println(stack.size()); System.out.println(stack.peek()); System.out.println(stack.pop()); System.out.println(stack.size()); System.out.println(stack.empty()); //java 已经实现了Stack类extends Vector Stack stack1 = new Stack(); stack1.push(2); System.out.println(stack1.size()); System.out.println(stack1.peek()); System.out.println(stack1.pop()); System.out.println(stack1.size()); System.out.println(stack1.empty()); System.out.println(&quot;---------------------&quot;); // 测试数组实现 栈大小固定 ArrayStack myStack = new ArrayStack(3); //myStack.push(3); //myStack.push(3); //myStack.push(3); //myStack.push(3); System.out.println(myStack.size()); System.out.println(myStack.peek()); System.out.println(myStack.pop()); System.out.println(myStack.empty()); &#125;&#125;//使用数组实现class ArrayStack &#123; private int top; private int[] data; private int maxSize; public ArrayStack(int cap) &#123; data = new int[cap]; maxSize = cap - 1; top = -1; &#125; public int size() &#123; return top+1; &#125; public boolean push(int value) &#123; if (top == maxSize) &#123; return false; &#125; else &#123; data[++top] = value; return true; &#125; &#125; public int pop() &#123; if (top == -1) &#123; return -1; &#125; else &#123; return data[top--]; &#125; &#125; //获得栈顶元素 public int peek() &#123; if (top == -1) &#123; return -1; &#125; else &#123; return data[top]; &#125; &#125; public boolean empty() &#123; if (top == -1) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125;//使用LinkedList实现class LinkedListStack &#123; private LinkedList linkedList = new LinkedList(); //进栈 public void push(Object obj) &#123; linkedList.addFirst(obj); &#125; //出站 移除第一个元素并返回 public Object pop() &#123; return linkedList.removeFirst(); &#125; //获得第一个元素（栈顶元素） public Object peek() &#123; return linkedList.getFirst(); &#125; public boolean empty() &#123; return linkedList.isEmpty(); &#125; public int size() &#123; return linkedList.size(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 多态小记]]></title>
      <url>%2F2017%2F05%2F26%2Fjava%2F2017-05-26%2F</url>
      <content type="text"><![CDATA[Java 多态小记 什么是多态 1.面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。2.多态的定义：指允许不同类的对象对同一消息（方法函数调用）做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用），3.实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。(父类对象应用指向子类的实例对象)4.多态的作用：消除类型之间的耦合关系。5.运行时多态存在的三个必要条件：一、要有继承（包括接口的实现）；二、要有重写；三、父类引用指向子类对象。 对静态方法的调用不存在任何动态的分派机制（不存在多态性）。当一个程序调用了一个静态方法，要被调用的方法都是在编译时就被选定的，即调用哪个方法是根据该引用被声明的类型决定的。 注意：静态方法不能被重写为非静态的方法（会编译出错） 1234567891011121314151617181920212223242526272829303132333435public class G0526 &#123; public static void main(String args[]) &#123; A a = new A(); A b = new B(); a.method1(); //class A method1 b.method1();//class B method1 a.method2(); //class A method2 b.method2();//class A method2 &#125;&#125;class A &#123; public void method1() &#123; System.out.println(&quot;class A method1&quot;); &#125; public static void method2() &#123; System.out.println(&quot;class A method2&quot;); &#125;&#125;class B extends A &#123; public void method1() &#123; System.out.println(&quot;class B method1&quot;); &#125; public static void method2() &#123; System.out.println(&quot;class B method2&quot;); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[springboot启动器]]></title>
      <url>%2F2017%2F05%2F22%2Fspringboot%2F2017-05-22-1%2F</url>
      <content type="text"><![CDATA[#springboot启动器 Spring Boot应用启动器基本的一共有（现知道的是44）种：具体如下： 1）spring-boot-starter这是Spring Boot的核心启动器，包含了自动配置、日志和YAML。2）spring-boot-starter-actuator帮助监控和管理应用。3）spring-boot-starter-amqp通过spring-rabbit来支持AMQP协议（Advanced Message Queuing Protocol）。4）spring-boot-starter-aop支持面向方面的编程即AOP，包括spring-aop和AspectJ。5）spring-boot-starter-artemis通过Apache Artemis支持JMS的API（Java Message Service API）。6）spring-boot-starter-batch支持Spring Batch，包括HSQLDB数据库。7）spring-boot-starter-cache支持Spring的Cache抽象。8）spring-boot-starter-cloud-connectors支持Spring Cloud Connectors，简化了在像Cloud Foundry或Heroku这样的云平台上连接服务。9）spring-boot-starter-data-elasticsearch支持ElasticSearch搜索和分析引擎，包括spring-data-elasticsearch。10）spring-boot-starter-data-gemfire支持GemFire分布式数据存储，包括spring-data-gemfire。11）spring-boot-starter-data-jpa支持JPA（Java Persistence API），包括spring-data-jpa、spring-orm、Hibernate。12）spring-boot-starter-data-mongodb支持MongoDB数据，包括spring-data-mongodb。13）spring-boot-starter-data-rest通过spring-data-rest-webmvc，支持通过REST暴露Spring Data数据仓库。14）spring-boot-starter-data-solr支持Apache Solr搜索平台，包括spring-data-solr。15）spring-boot-starter-freemarker支持FreeMarker模板引擎。16）spring-boot-starter-groovy-templates支持Groovy模板引擎。17）spring-boot-starter-hateoas通过spring-hateoas支持基于HATEOAS的RESTful Web服务。18）spring-boot-starter-hornetq通过HornetQ支持JMS。19）spring-boot-starter-integration支持通用的spring-integration模块。20）spring-boot-starter-jdbc支持JDBC数据库。21）spring-boot-starter-jersey支持Jersey RESTful Web服务框架。22）spring-boot-starter-jta-atomikos通过Atomikos支持JTA分布式事务处理。23）spring-boot-starter-jta-bitronix通过Bitronix支持JTA分布式事务处理。24）spring-boot-starter-mail支持javax.mail模块。25）spring-boot-starter-mobile支持spring-mobile。26）spring-boot-starter-mustache支持Mustache模板引擎。27）spring-boot-starter-redis支持Redis键值存储数据库，包括spring-redis。28）spring-boot-starter-security支持spring-security。29）spring-boot-starter-social-facebook支持spring-social-facebook30）spring-boot-starter-social-linkedin支持pring-social-linkedin31）spring-boot-starter-social-twitter支持pring-social-twitter32）spring-boot-starter-test支持常规的测试依赖，包括JUnit、Hamcrest、Mockito以及spring-test模块。33）spring-boot-starter-thymeleaf支持Thymeleaf模板引擎，包括与Spring的集成。34）spring-boot-starter-velocity支持Velocity模板引擎。35）spring-boot-starter-webS支持全栈式Web开发，包括Tomcat和spring-webmvc。36）spring-boot-starter-websocket支持WebSocket开发。37）spring-boot-starter-ws支持Spring Web Services。 Spring Boot应用启动器面向生产环境的还有2种，具体如下：1）spring-boot-starter-actuator增加了面向产品上线相关的功能，比如测量和监控。2）spring-boot-starter-remote-shell增加了远程ssh shell的支持。 最后，Spring Boot应用启动器还有一些替换技术的启动器，具体如下：1）spring-boot-starter-jetty引入了Jetty HTTP引擎（用于替换Tomcat）。2）spring-boot-starter-log4j支持Log4J日志框架。3）spring-boot-starter-logging引入了Spring Boot默认的日志框架Logback。4）spring-boot-starter-tomcat引入了Spring Boot默认的HTTP引擎Tomcat。5）spring-boot-starter-undertow引入了Undertow HTTP引擎（用于替换Tomcat）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring boot 之Controller简单单元测试（RESTful API）]]></title>
      <url>%2F2017%2F05%2F22%2Fspringboot%2F2017-05-22%2F</url>
      <content type="text"><![CDATA[#spring boot 之Controller简单单元测试（RESTful API） MocMvc做为服务端测试类，功能十分强大；在spring全家桶中，在springMVC和springboot中都可以使用，用法十分相似。 首先需要在pom.xml中加入依赖配置。 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; ###第一种使用注解方法注入MocMvc//@RunWith(SpringJUnit4ClassRunner.class) SpringRunner extends SpringJUnit4ClassRunner@RunWith(SpringRunner.class)@WebAppConfiguration //支持web项目注解@SpringBootTest////(classes = DemoApplication.class, webEnvironment = SpringBootTest.WebEnvironment.MOCK)指定SpringBoot工程的Application启动类@AutoConfigureMockMvcpublic class TestController { @Autowired private MockMvc mockMvc; @Autowired private UserService userService; @Test public void testUser() throws Exception { //提交请求 构建RequestBuilder对象，模拟request请求 RequestBuilder request = null; request = MockMvcRequestBuilders.get(&quot;/&quot;); mockMvc.perform(request).andExpect(status().isOk()).andReturn(); mockMvc.perform((post(&quot;/hello&quot;))).andExpect(status().isOk()) .andDo(print()).andReturn(); } ###第二种手动注入MocMvc（分为集成web环境和独立测试方式） 123456789101112131415161718192021222324252627282930@RunWith(SpringRunner.class)@WebAppConfiguration //支持web项目注解@SpringBootTest////(classes = DemoApplication.class, webEnvironment = SpringBootTest.WebEnvironment.MOCK)指定SpringBoot工程的Application启动类public class TestController &#123; private MockMvc mockMvc; @Autowired private WebApplicationContext wac;//集成Web环境方式 () @Before public void setUp() &#123; this.mockMvc = webAppContextSetup(this.wac).build(); &#125; //独立测试 //@Before //public void setUp() &#123; // IndexController indexController =new IndexController(); // this.mockMvc = MockMvcBuilders.standaloneSetup(indexController).build(); //&#125; @Test public void testUser() throws Exception &#123; //提交请求 构建RequestBuilder对象，模拟request请求 RequestBuilder request = null; request = MockMvcRequestBuilders.get(&quot;/&quot;); mockMvc.perform(request).andExpect(status().isOk()).andReturn(); mockMvc.perform((post(&quot;/hello&quot;))).andExpect(status().isOk()) .andDo(print()).andReturn(); &#125; 1、@WebAppConfiguration：测试环境使用，用来表示测试环境使用的ApplicationContext将是WebApplicationContext类型的；value指定web应用的根；2、通过@Autowired WebApplicationContext wac：注入web环境的ApplicationContext容器；3、然后通过MockMvcBuilders.webAppContextSetup(wac).build()创建一个MockMvc进行测试； 几个常用的方法： perform：执行一个RequestBuilder请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理；andExpect：添加ResultMatcher验证规则，验证控制器执行完成后结果是否正确；andDo：添加ResultHandler结果处理器，比如调试时打印结果到控制台；andReturn：最后返回相应的MvcResult；然后进行自定义验证/进行下一步的异步处理； 参考 spring boot 基于Controller自动化测试demoJunit学习笔记之五：MockMVC]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[springboot 将默认web容器tomcat 换成 jetty]]></title>
      <url>%2F2017%2F05%2F21%2Fspringboot%2F2017-05-21-1%2F</url>
      <content type="text"><![CDATA[springboot 将默认web容器tomcat 换成 jetty springboot框架默认集成（tomcat或jetty）web容器，web容器也使用默认配置，不过也可在配置文件（application.properties）中进行重写覆盖；springboot项目的启动方式和java程序类似，使用main（）方法启动非常方便快捷（也可以使用maven命令启动 mvn spring- boot:run）。框架默认使用tomcat容器，下面介绍如何将默认容器tomcat换成jetty容器。 ###第一步修改pom.xml的配置，将原来的默认的tomcat依赖配置去掉；新增jetty依赖 123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!--把pom中的tomcat依赖排除--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--增加jetty依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ###第二步（方法一）在(DemoApplication.java命名可能不同)启动类中继承SpringBootServletInitializer类重写configure（）方法； 1234567891011@SpringBootApplicationpublic class DemoApplication extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; return builder.sources(this.getClass()); &#125; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; ###第二步（方法二）注入Jetty容器的管理Bean，在(DemoApplication.java命名可能不同)启动类中： 12345678910111213@SpringBootApplicationpublic class DemoApplication &#123; @Bean public EmbeddedServletContainerFactory servletContainer() &#123; JettyEmbeddedServletContainerFactory factory = new JettyEmbeddedServletContainerFactory(); return factory; &#125; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 内置服务器配置覆盖说明使用可参见其他blog；项目亦可打包成war包手动放置web容器（tomcat，weblogic等）中进行项目部署。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[how to use idea create a springboot web project]]></title>
      <url>%2F2017%2F05%2F21%2Fspringboot%2F2017-05-21%2F</url>
      <content type="text"><![CDATA[#how to use idea create a springboot web project 第一步：打开idea，点检File–&gt;New–&gt;project 第二步： 第三步： 第四步： 第五步： 第六步：生成的项目结构]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JVM概况了解]]></title>
      <url>%2F2017%2F05%2F14%2Fjvm%2FJVM%2F2017-05-14-1%2F</url>
      <content type="text"><![CDATA[JVM了解学习 Java程序的跨平台特性主要是指字节码文件可以在任何具有Java虚拟机的计算机或者电子设备上运行，Java虚拟机中的Java解释器负责将字节码文件解释成为特定的机器码进行运行。因此在运行时，Java源程序需要通过编译器编译成为.class文件。众所周知java.exe是Java class文件的执行程序，但实际上java.exe程序只是一个执行的外壳，它会装载jvm.dll（windows下，下皆以windows平台为例，Linux下和solaris下其实类似，为：libjvm.so），这个动态连接库才是java虚拟机的实际操作处理所在。 JVM是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。所以，JAVA虚拟机JVM是属于JRE的，而现在我们安装JDK时也附带安装了JRE(当然也可以单独安装JRE)。 JVM = 类加载器 classloader + 执行引擎 execution engine + 运行时数据区域 runtime data areaclassloader 把硬盘上的class 文件加载到JVM中的运行时数据区域, 但是它不负责这个类文件能否执行，而这个是 执行引擎 负责的。 ##类加载器：作用：装载.class文件classloader 有两种装载class的方式 （时机）：隐式：运行过程中，碰到new方式生成对象时，隐式调用classLoader到JVM显式：通过class.forname()动态加载类加载器 classloader 是具有层次结构的，也就是父子关系。其中，Bootstrap 是所有类加载器的父亲。这个类加载器不是用 java 语言写的，而是用 C/C++ 写的。 ##执行引擎：作用： 执行字节码，或者执行本地方法 ##运行时数据区：主要包括： Java虚拟机栈：java 虚拟机栈也是线程私有的。每一个 JVM 线程都有自己的 java 虚拟机栈，这个栈与线程同时创建，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程 本地方法栈：与虚拟机栈的作用相似，虚拟机栈为虚拟机执行执行java方法服务，而本地方法栈则为虚拟机使用到的本地方法服务。 java堆：被所有线程共享的一块存储区域，在虚拟机启动时创建，它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配。（JVM将Heap分为两块：新生代New Generation和旧生代Old Generation）， PC程序计数器：一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器, NAMELY存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。Java 的多线程机制离不开程序计数器，每个线程都有一个自己的PC，以便完成不同线程上下文环境的切换。 方法区：方法区和堆区域一样，是各个线程共享的内存区域，它用于存储每一个类的结构信息，例如运行时常量池，成员变量和方法数据，构造函数和普通函数的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。当开发人员在程序中通过Class对象中的getName、isInstance等方法获取信息时，这些数据都来自方法区。 运行时常量池：（其空间从方法区中分配，存放的为类中固定的常量信息、方法和域的引用信息）参见个人学习整理的JVM运行时数据区域总结 ##垃圾回收机制GC。垃圾回收机制是由垃圾收集器Garbage Collection GC来实现的，GC是后台的守护进程。垃圾回收是一种动态存储管理技术，它自动地释放不再被程序引用的对象，按照特定的垃圾收集算法来实现资源自动回收的功能。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用，以免造成内存泄露。参考个人GC学习总结 JVM 的 工作原理，层次结构 以及 GC工作原理Java内存管理：深入Java内存区域]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hibernate学习笔记]]></title>
      <url>%2F2017%2F05%2F11%2Fhibernate%2F2017-05-11%2F</url>
      <content type="text"><![CDATA[hibernate学习笔记1.Hibernate里不对对象或集合对象重载toString方法，不然编译错误 。Stackoverflow错误 栈溢出 2.什么是维护关联关系：一对多时候 设置外键的值多对多时候 就是插入或删除中间表的记录 3对象的状态： 临时状态： 与数据库没有对应，跟Session没有关联。 一般是新new出的对象。 持久化状态： 对象在Session的管理之中，最终会有对应的数据库记录。 特点： a，有OID b，对对象的修改会同步到数据库。 游离状态： 数据库中有对应记录，但对象不在Session管理之中。 修改此状态对象时数据库不会有变化。 4.主键id的生成 &lt;id name=&quot;id&quot;&gt; 5.数据库sql的四个级别：读未提交 1 0001读已提交 2 0010可重复度 4 0100串行化（不可并发） 8 10006.一对一：外键约束 + 唯一性约束比较特殊只有有外键方的一方才能维护关联关系所有解除关联是，没外键的一方解除无效。基于外键的一对一基于主键的一对一 person 在having中不能使用列别名，order by 可以用 8.java中为什么要给类使用代理，有什么好处 http://www.iteye.com/problems/15304 9.懒加载： 也叫延迟加载，不是在执行获取操作时马上生成SQL，而是在第一次使用时生成SQL。 分成两种： 类级别的： &lt;class ... lazy=&quot;true/false&quot;&gt; 属性级别的： &lt;set/list/map/bag ... lazy=&quot;...&quot;&gt; &lt;many-to-one ... lazy=&quot;...&quot;&gt; &lt;one-to-one ... lazy=&quot;...&quot;&gt; 在使用懒加载特性时，可能会有LazyInitializationException异常： 原因： 真正的去获取数据时，Session已经没有了。 解决办法： 方式一：让Session在真正加载后再关闭。 方式二：或是在Sessoin关闭前执行Hibernate.initialize(department.getEmployees()); extra策略：（加强懒加载） 注意！！！与 lazy=“true” 类似. 主要区别是增强延迟检索策略能进一步延迟 Customer 对象的 orders 集合代理实例的初始化时机：• 当程序第一次访问 orders 属性的 iterator() 方法时, 会导致 orders 集合代理类实例的初始化• 当程序第一次访问 order 属性的 size(), contains() 和 isEmpty() 方法时, Hibernate 不会初始化 orders 集合类的实例,仅通过特定的 select 语句查询必要的信息, 不会检索所有的 Order 对象 10.缓存是按id来查询的！ （使用id获得对象 才有效）一级缓存 相对于类对象，二级缓存 相对于sessionfactory，应用级别的缓存。在session查询数据库前的缓存 注意！！！ 对于集合里的二级缓存，不仅要声明此时对象里的集合属性要二级缓存，而且集合里的对应类型对象也要声明是二级缓存。这样才能实现二级缓存的效果！不然的话虽然第一次查询这个集合里的所有数据，第二次查询是集合里的对象所对应的属性还是要再按照其自身的id依次查询（生成对个sql语句），不好。 缓存一般使用在load和get方法query.list()查询方法默认不使用缓存。就算hql语句后又where id=。。。都不行。1.如果要使用query.list()那么要使用迭代器 iterator()；不过有n+1次查询问题，不常用！！！2.也可以使用 .setCacheable(true)// 是否使用查询缓存，需要在hibernate.cfg.xml中开启查询缓存才行(不过hql条件要一致) 1. select new list(p.name, p.address) from Person as p ; select将选择出来的属性存入一个List对象中 select new ClassTest(p.name, p.address) from Person as p;select将选择出来的属性封装成对象,前提是ClassTest支持p.name, p.address的构造函数, select new map(p.name as personName) from Person as p ;select将选中的表达式命名为别名,这种用法与new map()结合,选择出来的是Map结构,以personName为key,将实际选择出来的值作为value]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的基本数据类型和引用类型]]></title>
      <url>%2F2017%2F05%2F10%2Fjava%2Fjava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F2017-05-10%2F</url>
      <content type="text"><![CDATA[java的基本数据类型和引用类型 基本类型：简单数据类型是不能简化的、内置的数据类型、由编程语言本身定义，它表示了真实的数字、字符和整数。 引用数据类型：Java语言本身不支持C++中的结构（struct）或联合（union）数据类型，它的复合数据类型一般都是通过类或接口进行构造，类提供了捆绑数据和方法的方式，同时可以针对程序外部进行信息隐藏 一、8种基本基本数据类型（分布尔类型和数值类型）。1、4种整型 byte 1字节 -128——127 short 2 字节 -32,768 —— 32,767 int 4 字节 -2,147,483,648 —— 2,147,483,647（超过20亿） long 8 字节 -9,223,372,036,854,775,808——9,223,372,036854,775,807 注释：java中所有的数据类所占据的字节数量与平台无关，java也没有任何无符号类型2、 2种浮点类型 float 4 字节 32位IEEE 754单精度（有效位数 6 – 7位） double 8 字节 64位IEEE 754双精度（有效位数15位）3、1种Unicode编码的字符单元 char 2 字节 整个Unicode字符集4、1种真值类型 boolean 1 位 true或者false ##二、种引用类型类class接口interface数组array ##三、Java数据类型在内存中的存储： 给变量赋值前需要先确定变量的类型，确定了变量的类型，即确定了数据需分配内存空间的大小，数据在内存的存储方式。1）基本数据类型的存储原理：所有的简单数据类型不存在“引用”的概念，基本数据类型都是直接存储在内存中的内存栈上的，数据本身的值就是存储在栈空间里面，而Java语言里面八种数据类型是这种存储模型； 2）引用类型的存储原理:引用类型继承于Object类（也是引用类型）都是按照Java里面存储对象的内存模型来进行数据存储的，使用Java内存堆和内存栈来进行这种类型的数据存储，简单地讲，“引用”是存储在有序的内存栈上的（存储对象地址），而对象本身（实例化后的对象）的值存储在内存堆上的； 区别:基本数据类型和引用类型的区别主要在于基本数据类型是分配在栈上的，而引用类型是分配在堆上的()（需要java中的栈、堆概念） 四、“==”和equal()对数据类型的分析:12345678910111213eg1:定义两个String对象（String不是基本数据类型）//String是一个特殊的包装类数据。可以用以下两种方式创建：//String str = new String(“abc”)；String str = “abc”;String a=&quot;abc&quot;;//栈中的a引用变量指向JVM运行时数据区区域方法区的常量池中的“abc”。String b=&quot;abc&quot;;//栈中的b引用变量也指向方法区中的常量池中的&quot;abc&quot;，和a指向的地址一样String c = new String(&quot;abc&quot;); //new一个新的String实例对象，引用变量c指向实例化对象new String(&quot;abc&quot;)的地址，该实例化对象存储在堆中[ **实际该地址指针（地址存在堆中）指向此对象类型数据（存在方法区中数据值）即abc**]，这和存在常量池的“abc”值得地址不一样。if(a==b)&#123;System.out.println(&quot;a==b&quot;);&#125;else&#123;System.out.println(&quot;a!=b&quot;);&#125;System.out.printLn(a==c) 结果：程序输出a==b flase原因:a和b引用变量指向的地址的是相同的，a==b比较的是两个引用变量所指向的地址。 a和c引用变量指向的地址的是不相同的，a指向常量区中的abc，c指向新开辟在堆内存中的String对象实例中的abc实例对象中数据值得地址；两个地址不同，==比较返回false。 images 参考eg2：定义两个基本数据类型 12345678int a=4; //栈中的a引用变量指向方法区中的常量池中的4int b=4; //栈中的b引用变量也指向方法区中的常量池中的4if(a==b)&#123;System.out.println(&quot;a==b&quot;);&#125;else&#123; System.out.println(&quot;a!=b&quot;); &#125; 结果：输出：a==b原因：a和b指向同一个常量区中常量4的地址。==比较两者地址相等。 不管是引用类型或基本数据类型使用“==”比较，实际上他们都先在栈空间创建了一个各自的变量引用如int a=1 或String b 等，并比较他们指向的地址的值； 如果给基本数据类型赋值，实际是先将在方法区中的常量区中查找是否存在值1的地址（该值有一个唯一的地址），如果存在则将a指向该地址；不存在那么在常量区新建一个值为1的空间，并将该值得地址赋值给a。如果重新给a赋值如：a = 2，同理将a指向的地址改为常量区中值为2的地址。注意 int c =1，代表a和b指向同一个地址（常量区中1的地址）。 如果使用new 实例化对象，对象的引用变量指向的是在堆中该对象实例化的对象地址； equal()方法比较的是引用变量指向地址最终指向的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java集合汇总]]></title>
      <url>%2F2017%2F05%2F09%2Fjava%2F%E9%9B%86%E5%90%88%2F2017-05-09%2F</url>
      <content type="text"><![CDATA[java集合汇总几个主要结合的主要关系：Collection├List│├LinkedList│├ArrayList│└Vector│ └Stack└SetMap├Hashtable├HashMap└WeakHashMap 一、集合与数组 数组：是用来存储对象（存储对象的引用，java的基本数据类型和引用类型）和基本数据类型的一种容器，但是数组的长度在创建时候已经固定，不适合在对象数量未知的情况下使用。 集合：通俗的讲集合是一个存放数据的容器，准确的讲集合是一个 存放数据对象引用的容器，并非对象本身。（只能存储对象，对象类型可以不一样），集合长度可变，可在多数情况下使用。注意：集合存放的都是对象的引用，那些看似存放着基本数据类型其实已经通过java自动装，拆箱操作装成了相应的对象。123List list =new ArrayList();list.add(12);System.out.println(list.get(0).getClass().getName());//Integer类型 自动装、拆箱 二、层次关系 如图所示：图中，实线边框的是实现类，折线边框的是抽象类，而点线边框的是接口： ##集合框架图： Collection接口是集合类的根接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了两个接口，就是Set和List。Set中不能包含重复的元素（set集合的去重原理）。List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式。 Map是Java.util包中的另一个接口，它和Collection接口没有关系，是相互独立的，但是都属于集合类的一部分。Map包含了key-value对。Map不能包含重复的key，但是可以包含相同的value。 Iterator（迭代接口），所有的集合类，都实现了Iterator接口，所以不论Collection实际类型是哪一个都支持iterator()的方法，该方法返回一个迭代子。这是一个用于遍历集合中元素的接口，主要包含以下三种方法：1.hasNext()是否还有下一个元素。2.next()返回下一个元素。3.remove()删除当前元素。典型使用：1234Iterator it = collection.iterator(); // 获得一个迭代子 while(it.hasNext()) &#123; Object obj = it.next(); // 得到下一个元素 &#125; 注意：Collection collection = new ArrayList();（这样写的好处在于，以后如果要引用不同的集合，可以省略很多麻烦。因为都是用Collection接口里的方法，java多态的提现，向上转型）容器类对象在调用remove,contains等方法时需要比较对象是否相等地，这会涉及到对象类型的equals方法和hashcode方法。即，相等的对象应该有相等的hashcode.当然，如果是自定义的类型，需要重写这两个方法 三、几种重要的集合接口和类简介 1、List（有序、可重复）List 接口继承了 Collection 接口以定义一个允许重复项的有序集合。该接口不但能够对列表的一部分进行处理，还添加了面向位置的操作。有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。List 接口提供了特殊的迭代器，称为 ListIterator，除了允许 Iterator 接口提供的正常操作外，该迭代器还允许元素插入和替换，以及双向访问。还提供了一个方法来获取从列表中指定位置开始的列表迭代器注意：尽管列表允许把自身作为元素包含在内，但建议要特别小心：在这样的列表上，equals 和 hashCode 方法不再是定义良好的。 2、Set（无序、不能重复）Set接口同样是Collection接口的一个子接口，它表示数学意义上的集合概念。Set中不包含重复的元素，即Set中不存两个这样的元素e1和e2，使得e1.equals(e2)为true。由于Set接口提供的数据结构是数学意义上集合概念的抽象，因此它需要支持对象的添加、删除，而不需提供随机访问。故Set接口与Collection的接口相同。Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，set可以存入null和boolean型。 3、Map（键值对、键唯一、值不唯一）Map 接口不是 Collection 接口的继承。而是从自己的用于维护键-值关联的接口层次结构入手。按定义，该接口描述了从不重复的键到值的映射。Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。 四、遍历 在类集中提供了以下四种的常见输出方式：1）Iterator：迭代输出，是使用最多的输出方式。2）ListIterator：是Iterator的子接口，专门用于输出List中的内容。3）foreach输出：JDK1.5之后提供的新功能，可以输出数组或集合。4）for循环代码示例如下：12345for的形式：for（int i=0;i&lt;arr.size();i++）&#123;...&#125;foreach的形式： for（int i：arr）&#123;...&#125;iterator的形式：Iterator it = arr.iterator();while(it.hasNext())&#123; object o =it.next(); ...&#125; 集中常用的对应实现类总结五、（实现List集合接口）ArrayList、LinkedList，和VectorArrayList和LinkedList在用法上没有区别，但是在功能上还是有区别的。LinkedList经常用在增删操作较多而查询操作很少的情况下，ArrayList则相反。即：ArrayList ：读快改慢，动态数组 LinkedList：改快读慢，链表，队列，堆栈。 Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。 六、Set集合（HashSet和TreeSet）HashSet：使用哈希表实现的，HashSet集合是无序的，可以存入null当只能存一个，存入的对象或数据唯一。TresSet：使用二叉树实现，集合是有序且自动排列好的（默认升序排序）。可以通过实现Comparable接口，重写接口里面的compareTo(Object obj)方法来自定义排序，该方法返回一个整数值。该集合不允许放入null值。参考：TreeSet和HashSet的区别注意：HashSet 和 TreeSet 都实现 Cloneable 接口。HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相同内容的 String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例 。 七、Map集合 实现类：HashMap、Hashtable、LinkedHashMap和TreeMap HashMapHashMap是最常用的Map（无序的），它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。因为键对象不可以重复，所以HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null，是非同步的，效率高。 HashtableHashtable与HashMap类似，是HashMap的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低。 ConcurrentHashMap线程安全，并且锁分离。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。 LinkedHashMapLinkedHashMap保存了记录的插入顺序（有序的），在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。 TreeMapTreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，非同步的；所以在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按顺序遍历键，那么TreeMap 会更好。自定义排序例子：123456789TreeMap&lt;Double,Object&gt; rf = new TreeMap&lt;Double,Object&gt;(new Comparator()&#123; @Override public int compare(Object o1, Object o2) &#123; // TODO Auto-generated method stub 重写compare方法，降序排列 Double a = (Double)o1; Double b = (Double)o2; return -a.compareTo(b); &#125;&#125;); map的遍历 第一种：KeySet()将Map中所有的键存入到set集合中。因为set具备迭代器。所有可以迭代方式取出所有的键，再根据get方法。获取每一个键对应的值。 keySet():迭代后只能通过get()取key 。取到的结果会乱序，是因为取得数据行主键的时候，使用了HashMap.keySet()方法，而这个方法返回的Set结果，里面的数据是乱序排放的。典型用法如下：Map map = new HashMap();map.put(“key1”,”lisi1”);map.put(“key2”,”lisi2”);map.put(“key3”,”lisi3”);map.put(“key4”,”lisi4”);//先获取map集合的所有键的set集合，keyset（）Iterator it = map.keySet().iterator(); //获取迭代器while(it.hasNext()){Object key = it.next();System.out.println(map.get(key));} 第二种：entrySet（）Set]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java编译原理了解]]></title>
      <url>%2F2017%2F05%2F08%2Fjava%2Fjava%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%2F2017-05-08-1%2F</url>
      <content type="text"><![CDATA[java编译原理java源代码(符合语言规范)–&gt;javac–&gt;.class(二进制文件)–&gt;jvm–&gt;机器语言(不同平台不同种类) 语义分析器、语法分析器、语义分析器、代码生成器源码-&gt;token流-&gt;语法树-&gt;注解语法树-&gt;字节码images 流程： 词法分析器：将源码转换为Token流将源代码划分成一个个Token(找出java语言中的if，else，for等关键字) 语法分析器：将Token流转化为语法树将上述的一个个Token组成一句句话（或者说成一句句代码块），检查这一句句话是不是符合Java语言规范(如if后面跟的是不是布尔判断表达式) 语义分析器：将语法树转化为注解语法树将复杂的语法转化成简单的语法（eg.注解、foreach转化为for循环、去掉永不会用到的代码块）并做一些检查，添加一些代码(默认构造器) 代码生成器：将注解语法树转化为字节码(即将一个数据结构转化成另一个数据结构) ps：要获取javac编译器，可以通过OpenJDK来下载源码，可以自己编译javac的源码，也可以通过调用jdk的 学习参考Javac编译原理 Java编译原理（有感）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java对象转型]]></title>
      <url>%2F2017%2F05%2F08%2Fjava%2F2017-05-08%2F</url>
      <content type="text"><![CDATA[java对象转型 向上转型和向下转型 什么是对象转型?对象转型是在继承的基础上而言的，对象类型转换主要包含向上转型和向下转型。继承是java面向对象的基本特征之一，是代码复用的一种机制，通过继承子类可以复用父类的方法等；如果父类的方法不满足子类的需求，子类可以通过重写父类的方法或者新增属于自己特性的方法对自身的功能加以扩展。 1向上转型：子类引用的对象转换为父类类型称为向上转型。子类的对象转为父类对象，此处父类对象可以是接口。{eg：Annimal dog =new Dog();} 2向下转型：父类引用的对象转换为子类类型称为向下转型。{eg：Dog dog =new Animal();//不安全的向下转型上述编译通过，但是运行时候报错，类型转换错误！正确操作：Annimal ad =new Dog()；Dog dog = （Dog）ad；} 向上转型注意： 前者是一个向上转型，Animal dog 引用指向new Dog();子类对象当成父类对象，只能调用父类的成员，如果子类重写了父类的方法就根据这个引用指向调用子类重写的这个方法（这个方法就是覆盖override）。这个调用过程就称为“动态绑定”。（即子类重写父类方法，向上转型对象调用该方法，方法指向子类中重写的方法） 向上转型时，父类指向子类引用对象会遗失除与父类对象共有的其他方法，也就是在转型过程中，子类的新有的方法都会遗失掉，在编译时，系统会提供找不到方法的错误。如： 12345678910111213141516171819 public class Animal &#123; public void eat()&#123; System.out.println(&quot;animal eatting...&quot;); &#125;&#125;class Bird extends Animal&#123; public void eat()&#123; System.out.println(&quot;bird eatting...&quot;); &#125; public void fly()&#123; System.out.println(&quot;bird flying...&quot;); &#125;&#125;class Main&#123; public static void main(String[] args) &#123; Animal b=new Bird(); //向上转型 b.eat(); b.fly(); //此处提示在Animal中没有定义fly方法。｝ 向下转型注意：情况一：如果父类引用的对象如果引用的是指向的子类对象（即先向上转型），那么在向下转型的过程中是安全的。也就是编译是不会出错误的。此时对象可以调用子类所有的成员。情况二：如果父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现java.lang.ClassCastException错误。它可以使用instanceof来避免出错此类错误。 12345678910111213 class Main&#123; public static void main(String[] args) &#123; Animal b=new Bird(); //先向上转型（父类引用对象指向子类对象） Bird bird = (Bird) b;//向下转型，编译和运行都不报错 Animal a=new Animal(); //（父类引用对象指向父类本身对象） Bird bird = (Bird) a;//不安全的向下转型，编译正常，运行报错（类型转换错误） //解决方法 instance of if(a instanceof Bird)&#123; Bird bird=(Bird) a; bird.eat(); bird.fly(); &#125;｝ 总结：1、父类引用可以指向子类对象，子类引用不能指向父类对象。2、把子类对象直接赋给父类引用叫upcasting向上转型，向上转型不用强制转型。3、把指向子类对象的父类引用赋给子类引用叫向下转型（downcasting），要强制转型。4、upcasting 会丢失子类特有的方法,但是子类overriding 父类的方法，子类方法有效 。5、向上转型的作用，减少重复代码，父类为参数，调有时用子类作为参数，就是利用了向上转型。这样使代码变得简洁。体现了JAVA的抽象编程思想。 参考:夜雨阑珊]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Let Your Heart Hold Fast]]></title>
      <url>%2F2017%2F04%2F16%2Fmusic%2F2017-04-16%2F</url>
      <content type="text"><![CDATA[Let Your Heart Hold FastAll my days are spent 那飞速逝去的时日All my cards are dealt那已经确定的命运Oh ,the descolation grows悲凉无尽蔓延心脏Every inch revealed心脏每一寸As my heart is pierced都被刺穿Oh,my soul is now exposed灵魂彻底暴露In the ocean deep穿过深邃的海洋In the canyons steep越过险峻的峡谷Walls of granite here I stand我立在岩石之上All my desperate calls我所有绝望的呼唤Rcho off the walls在墙间回荡Back and forth;then back again久久不息To believe I walk alone相信自己能踽踽独行Is a lie that I’ve been told这是别人告诉我的谎言So let your heart hold fast所以不要灰心丧气For this soon shall pass因为一切都将成为过去Like the high tide takes the sand就像沙子会被海潮带走Oh,Oh,Oh,Oh,！哦~Oh,Oh,Oh,Oh,！哦~Oh,Oh,Oh,Oh,Oh！哦~Oh,Oh,Oh,Oh,！哦~Oh,Oh,Oh,Oh,！哦~Oh,Oh,Oh,Oh,Oh！哦~At the bitter end在痛苦的最后Salt and liquid blend泪水涌出From the corner of eyes从我的眼角滑落All the miles wrecked蹒跚走过的所有路Every broken step艰难走过的每一步Always searching,always blind一直在盲目的寻找Never fear!No!Never fear!不要畏惧！不要畏惧！Never fear!No! Never fear!永不畏惧！永不畏惧！So let your heart hold fast所以不要灰心丧气For this soon shall pass因为一切将成为过去There’s another hill ahead前方将是人生的另一座高峰&gt; 这世上总有很多我们无法掌控的事情，就像我想你一样，总是那么的不经意间。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flask get/post参数获取]]></title>
      <url>%2F2017%2F03%2F22%2Fpython%2Fflask%2F2017-03-22%2F</url>
      <content type="text"><![CDATA[flask 使用笔记获得get和post 提交的参数post 提交参数获取request.form[‘xxx’] 其类型为：ImmutableMultiDict123456@app.route(&quot;/deleteInfo&quot;, methods=[&apos;post&apos;])@allow_cross_domaindef delete_info(): print(type(request.form)) # &lt; class &apos;werkzeug.datastructures.ImmutableMultiDict&apos;&gt; _id = request.form[&quot;_id&quot;] get 提交参数获取1234@app.route(&apos;/queryDetl&apos;)@allow_cross_domaindef query_detail(): _id = request.args.get(&quot;_id&quot;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决Flask 跨域请求问题]]></title>
      <url>%2F2017%2F03%2F21%2Fpython%2Fflask%2F2017-03-21%2F</url>
      <content type="text"><![CDATA[python flask 跨域访问装饰器实现现在大多数的web项目都已经是前后端分离；一般纯的api接口需要考虑跨域访问问题 下面是简单的跨域访问装饰器在flask中的实现（其他语言web项目跨域处理方法类似）12345678910111213141516171819from functools import wrapsfrom flask import make_responsedef allow_cross_domain(fun): @wraps(fun) def wrapper_fun(*args, **kwargs): rst = make_response(fun(*args, **kwargs)) rst.headers[&apos;Access-Control-Allow-Origin&apos;] = &apos;*&apos; rst.headers[&apos;Access-Control-Allow-Methods&apos;] = &apos;PUT,GET,POST,DELETE&apos; allow_headers = &quot;Referer,Accept,Origin,User-Agent&quot; rst.headers[&apos;Access-Control-Allow-Headers&apos;] = allow_headers return rst return wrapper_fun@app.route(&apos;/hosts/&apos;)@allow_cross_domaindef domains(): pass]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[my first hexo]]></title>
      <url>%2F2017%2F03%2F20%2Fmy-first-hexo%2F</url>
      <content type="text"><![CDATA[hello glinlf and hexo!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F19%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何使用grequests 异步IO批量请求]]></title>
      <url>%2F2017%2F03%2F18%2Fspider%2F2017-03-18%2F</url>
      <content type="text"><![CDATA[python grequests 库的使用记录 简介： 对于大名鼎鼎的request库相信大家都已经非常熟悉了，不过他有个不好的缺点就是阻塞性IO，在你使用request.get()获取所需要的网页时，除非这个网页下载完成，不然不能进行对新网页的获取；而cup的处理速度远比IO读写的速度快多了，为了充分利用cpu，加快网页爬取速度，这里讲介绍使用异步IO获取网页的grequests库的使用。这两个库都是 kennethreitz开发的，用法非常相似。 安装installpip install grequests 基础用法 12345678910111213141516171819#要爬取的url集合urls = [ url = &apos;https://www.zhihu.com/people/excited-vczh/following&apos;, url = &apos;https://www.zhihu.com/people/liaoxuefeng/following&apos;, url = &apos;https://www.zhihu.com/people/hellolin-30/following&apos;]#同时将上述请求发送rs = (grequests.get(u) for u in urls)#查看发送请求的响应状态码和响应结果： respond_html=[] for resp in grequests.map(rs, exception_handler=exception_handler): # grequests.map可以查看异步io么一个请求返回的状态码200 500 # print(&apos;status:&#123;0&#125; url:&#123;1&#125;&apos;.format(resp, resp.url)) if resp is not None: respond_html.append(resp.text) else: continue 异常的处理 12def exception_handler(request, exception): print(&apos;got exception request: &#123;0&#125;, exception &#123;1&#125;&apos;.format(request, exception)) 异步IO实际运用效果的反思： a.原本毕设在做一个基于python的知乎用户信息特征爬虫系统的，为了加快爬取速度思考使用异步IO，主要思路： 1 对用户信息的的请求入口使用异步IO（grequests）请求多个url地址 2 每一个用户关注人又有多个分页，对分页进行异步IO请求。 原先未使用grequests库，由于阻塞IO的影响，每次只能爬取一个用户信息，再爬取每一用户第一页下的关注人url地址（实际未爬全所有该用户关注的用户）；速度爬取相对较快；使用grequests后去爬取某个用户所有分页下的关注人url后，速度开始变慢，主要原因是：在爬取这个用户后，接着要全部爬完和解析所有分页的html（基本爬全所有关注的用户）；比如某个用户关注上万人，系统爬取该用户下所有关注人都要耗费大把时间。所以异步IO提速还需要看实际的运用情况和环境。比如本身网络带宽限制，机器硬件限制等等都会影响到整体的速度。 b.爬取过程的问题： 虽然该系统只是爬取用户的关注人，不爬取被关注人信息。所以不存在关注和被关注的关系，当是存在 多个人关注同一个人的情况，所以如果爬取所有每个人的关注人，仍然存在爬取了很多重复性爬过的过户，特别是爬取解析分页网页（某个用户关注人特别多的情况）；耗费资源时间却做很多无用功。 个人解决方法：控制爬取的分页数（实际爬去的分页数还需算法和大数据理论支撑），概率性爬取关注人的url（分页下）。存在多人关注同一人的关系便存在概率性爬取到此用户的可能。 缺点：部分概率爬取不到关注用户；爬取的用户数据不全。 grequets使用代理12proxies = &#123;&apos;http&apos;: &apos;http://219.148.108.126:8998&apos;&#125;s = (grequests.get(u, proxies=proxies) for u in urls) 参考 https://pypi.python.org/pypi/grequests https://github.com/kennethreitz/grequests http://blog.upeoe.com/2016/11/24/how-to-use-grequest/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python全局变量]]></title>
      <url>%2F2017%2F03%2F17%2Fpython%2F2017-03-17%2F</url>
      <content type="text"><![CDATA[python全局变量使用: 1 可以直接定义一个globalvar.py文件；里面存放其他文件要使用的变量。在其他文件中导入: 12345678910111213141516171819202122232425262728from src.globalvar import *# __author_=&quot;gLinlf&quot;# coding=utf-8import queue# 定义全局变量# 已经爬取得到所有urlhad_url = set()# 已经爬取解析用户的urlhad_used_url = set()# 用户关注的其他用户的url 使用队列（使用后删除）follow_url = queue.Queue(maxsize=0)# 爬虫入口# follow_url.put(&apos;https://www.zhihu.com/people/liaoxuefeng&apos;)follow_url.put(&apos;https://www.zhihu.com/people/competitionlaw&apos;)# 请求头header = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36&apos;&#125;# 数据库名db_name = &apos;test&apos;# 抽样爬取不大于10个分页的用户(200人)（加快用户信息爬取速度！概率性减少 花费早爬取页面中存在较多已经爬去的用户url 的资源和时间。）max_page = int(10)# 异步IO请求解析的最大页码数max_parse_page = int(5) 2使用global关键字声明]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mongodbengine 使用记录]]></title>
      <url>%2F2017%2F03%2F16%2Fmongodb%2F2017-03-16%2F</url>
      <content type="text"><![CDATA[mongoengine操作mongodb的使用笔记参见mongoengine文档 1 安装mongoengine pip install -U mongoengine 2 在python3.5中创建连接 mongoengine.connect（db = None，alias =’default’，** kwargs ） 2.1如果使用的时本地连接，则由’db’参数指定的数据库，直接连接数据库例如： mongoengine.connect(‘testdb’) 2.2如果数据库不在localhost的默认端口上运行，也可以在此处提供连接设置(如果需要验证，请提供用户名和密码参数。)： 1mongoengine.register_connection（alias，name = None，host = None，port = None，read_preference = Primary（），username = None，password = None，authentication_source = None，authentication_mechanism = None，** kwargs ） 参数： alias - 将用于在MongoEngine中引用此连接的名称 name - 要使用的特定数据库的名称 host - 要连接的mongod实例的主机名 port - mongod实例正在运行的端口 read_preference - 集合的读取首选项**添加pymongo 2.1 username - 要进行身份验证的用户名 密码 - 要验证的密码 authentication_source - 要进行身份验证的数据库 authentication_mechanism - 数据库认证机制。默认情况下，对MongoDB 3.0及更高版本使用SCRAM-SHA-1，对较旧的服务器使用MONGODB-CR（MongoDB Challenge Response协议）。 is_mock - 明确使用mongomock进行连接（也可以使用mongomock：//作为db主机前缀） kwargs - 要传递到pymongo驱动程序的特定参数，例如maxpoolsize，tz_aware等。有关完整列表，请参阅pymongo的MongoClient文档。 mongoengine在python中的基本使用：新增（save） 创建py文件testmongo.py 类为TestCategories ，TestCategories类似存入mongodb数据库中的表： import mongoengine class TestCategories(mongoengine.Document): # 用户信息地址 user_url = mongoengine.StringField() # 用户名 user_name = mongoengine.StringField() # 用户居住所在地 user_locations = mongoengine.ListField() 在另一个py文件创建一个测试文件 test.py: from src.testmogo import TestCategories from mongoengine import * connect(&apos;test&apos;) cate = TestCategories() cate.user_url = &apos;hello&apos; cate.user_name= &apos;python&apos; cate.user_locations = [&apos;llf&apos;] cate.save() 执行 test.py文件查看 数据库结果： 查询对于objects的到只是一个queryset类（QuerySet），这类里面有丰富的信息，存放所有查询到的 document对象（TestCategories）的list集合。可以使用for in list 语法将查询到的类对象里的数据灵活拼接成一个新的dict或list。 参考：Python中QuerySet和Objects类 obj = TestCategories.objects(user_url=&apos;123&apos;) #&lt;class &apos;mongoengine.queryset.queryset.QuerySet&apos;&gt; print(type(obj)) #&lt;TestCategories:TestCategoriesobject&gt; print(obj) for i in obj: print(i.user_url) 更新安装 django的web框架后 有update（）等方法。 obj = TestCategories.objects(user_url=&apos;123&apos;)获得的就是对应的document。 obj.user_url = &apos;321&apos; obj.update() 常规更新： obj = TestCategories.objects(user_url=&apos;123&apos;) #&lt;class &apos;mongoengine.queryset.queryset.QuerySet&apos;&gt; print(type(obj)) #[&lt;TestCategories: TestCategories object&gt;, &lt;TestCategories: TestCategories object&gt;] print(obj) for obj in objs: print(obj.user_url) # 直接操作 obj（TestCategories）对象 ，修改对应的字段值，更新！ obj.user_name = &apos;xx&apos; obj.save() 删除]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[How to use selenium]]></title>
      <url>%2F2017%2F03%2F13%2Fspider%2F2017-03-13%2F</url>
      <content type="text"><![CDATA[python 异步爬取库selenium使用记录简介 1 在做基于python的知乎用户信息特征爬虫系统中，遇到了个人信息需要点击 查看详细资料后 页面才能渲染出所有我所需要的用户信息。对于基于异步请求的动态网页爬虫，在研究了相关资料后发现这个暴力牛逼的包selenium，相对简单实用。简单来说就是模拟人为对浏览器的动作，比如：点击事件，填写表单等。这样就能克服操作我们传统爬虫只能爬取静态网页，得不到异步请求渲染后的网页信息。具体安装如下：安装selenium（python3.5，window10环境下） 1.通过pip安装 pip install selenium 2.通过下载selenium安装包 selenium连接https://pypi.python.org/pypi/selenium解压，cmd进入目录：E:\selenium\selenium2.53.5&gt; python3 setup.py install 安装浏览器驱动chromedriver（以google为例） 1.下载Chromedriver 下载地址：http://chromedriver.storage.googleapis.com/index.html 注意：先查看notes.txt，Chromedriver版本和浏览器版本一定要对应。否者会出现各种异常报错。 2.解压chromedriver.zip文件将里面的chromedriver.exe文件拷贝到谷歌浏览器的安装目录下： C:\Program Files (x86)\Google\Chrome\Application 3.配置环境变量 打开:我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量 打开path在最后面添加 ;C:\Program Files (x86)\Google\Chrome\Application 测试 打开python编辑器 如pyCharm 编辑代码： chromedriver = “C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe”os.environ[“webdriver.chrome.driver”] = chromedriverdriver = webdriver.Chrome(chromedriver)driver.get(‘http://www.baidu.com‘) 如果跳出google浏览器，且为百度页面则安装成功。不知道为什么其他博客只需要： driver = webdriver.Chrome()driver.get(‘http://www.baidu.com‘) 便能成功。而且我环境变量也已经配置。不知道啥原因，有待研究下。 ———————————————————————————————selenium使用记录模拟知乎登录（具体使用查看文档） 引用链接：https://www.zhihu.com/question/46528604?sort=created ###a先实例化一个driver chrome_driver = “C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe” os.environ[&quot;webdriver.chrome.driver&quot;] = chrome_driver driver = webdriver.Chrome(chrome_driver) ###b 登录知乎，亲自测试可行： driver.get(“http://www.zhihu.com“) #打开知乎我们要登录time.sleep(2) #让操作稍微停一下driver.find_element_by_link_text(‘登录’).click() #找到‘登录’按钮并点击time.sleep(2) # 找到输入账号的框，并自动输入账号 这里要替换为你的登录账号driver.find_element_by_name(‘account’).send_keys(‘你的账号’)time.sleep(2)# 密码，这里要替换为你的密码driver.find_element_by_name(‘password’).send_keys(‘你的密码’)time.sleep(2)# 输入浏览器中显示的验证码，这里如果知乎让你找烦人的倒立汉字，手动登录一下，再停止程序，退出#浏览器，然后重新启动程序，直到让你输入验证码yanzhengma=input(‘验证码:’) #现在好像不需要验证码driver.find_element_by_name(‘captcha’).send_keys(yanzhengma) # 找到登录按钮，并点击driver.find_element_by_css_selector(‘div.button-wrapper.command &gt; button’).click() ###c 使用driver.page_source 可以获得实际操作后的页面源码。而requests库只能获得打开连接的静态网页。如：html = driver.page_source接下来就可以使用BeautifulSoup库来自由操作了。]]></content>
    </entry>

    
  
  
</search>
